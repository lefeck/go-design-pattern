# 享元模式



## 定义

享元模式( Flyweight Pattern)，Flyweight 模式是以共享的模式来支持大量细粒度对象的复用。听起来可能有点绕，比如 Java 中的 String 就是享元模式的一个应用:

- String a= "abc";
- String b = "abc";
- System.out.printIn(a == b); // true

上述例子中，分别创建两个字符串对象的时候，a、b 其实都指向了常量池中的某个字符串 "abc”，这种对象创建的模式，就避免了大量对象创建时非必要的资源消耗，享元模式的“享”就有一物被众人所共享的意思，所以享元模式也是池技术的重要实现方式，其定义如下：**使用共享对象有效地支持大量的细粒度的对象。**



## UML类图



![1](https://doc.shiyanlou.com/courses/1851/1240622/b342bb5657c612e1a46d3fec4cb17313-0)

- 抽象享元角色( Flyweight)：一般是一个具体的抽象类，同时定义了对象的外部状态和内部状态的接口或实现；
- 具体享元角色( ConcreteFlyweight)：具体的一个产品类，实现了抽象享元角色中定义的接口，该角色需要注意的是内部状态的处理应该与环境无关；
- 享元工厂( FlyweightFactory)：该角色指责一般比较清晰，就是一个池工厂，提供池对象和获取池中对象的方法。



## 应用实例-考试


下面我们用一个最简单的考试报名的例子进行说明，假设我们有 2 个科目，有 3 位考生分别进行报考，我们一般会定义考试实体 ExamInfo，如果不使用模式的话，可以想象，每次有考生参与一场科目考试的话，我们就会实例化一个 ExamInfo，总共我们要实例化 6 个这样的实体，倘若使用享元模式，我们就只需要实例化 2 个这样的实体，然后通过内部状态的 set 方法进行不同对象的赋值操作，节省了内存，。

```go
package main

import (
    "fmt"
    "strconv"
)

type Flyweight interface {
    operate()
}


type ExamInfo struct {
    // 内部状态,用于在不同对象中共享
    user string

    // 外部状态，随环境改变而改变
    subject string
}

func (e *ExamInfo) operate() {
    fmt.Println(e.user,"开始考试，考试科目为",e.subject)
}

func (e *ExamInfo) User() string {
    return e.user
}

func (e *ExamInfo) SetUser(user string) {
    e.user = user
}

func (e *ExamInfo) Subject() string {
    return e.subject
}

func (e *ExamInfo) SetSubject(subject string) {
    e.subject = subject
}

func (e *ExamInfo) String () string {
    return "ExamInfo{" +
        "user = " + e.user + "\n" +
        "subject = " + e.subject + "\n" + "}"
}

// 享元工厂
type ExamInfoFactory struct {
    pool map[string]*ExamInfo
}

func (e *ExamInfoFactory)GetExamInfo(subject string) (Ex *ExamInfo) {
    if v,ok := e.pool[subject]; ok {
        Ex = v
        fmt.Println("直接从池中获取",subject)
    } else {
        fmt.Println("建立对象，并且放入池中",subject)
        Ex = &ExamInfo{subject:subject}
        e.pool[subject] = Ex
    }
    return
}
func main(){
    exF := &ExamInfoFactory{
        make(map[string]*ExamInfo),
    }
    for i := 0; i < 2; i++ {
        sub := "科目" + strconv.Itoa(i)
        exF.GetExamInfo(sub)
    }

    for i := 0; i < 3; i++ {
        for j := 0; j < 2; j++ {
            // 注意在此嵌套循环中，我们的Examinfo是由工厂返回出来的
            // 很显然我们只创建了两次这个对象，而不是像嵌套理所应当的六次
            Examinfo := exF.GetExamInfo("科目"+strconv.Itoa(j))
            Examinfo.SetUser("考生"+strconv.Itoa(i))
            fmt.Println(Examinfo)
            Examinfo.operate()
        }
    }
}
```

执行结果：

```
```



# 代理模式



## 定义

代理模式的定义其实比较简单：代理模式给某对象提供一个代理对象，由代理对象来控制对原对象的引用。生活中比较常见的代理模式的应用比如：火车票代购、代办保险、UU 跑腿、武侠片中的替身、nginx 反向代理等等这种类似于中介的模式统统可以归于代理模式。“本人” 和“代理人”都是对象，“ 代理人”可以代替“本人”去完成一些工作，甚至是出色完成(超期完成)某些工作，这里的“出色完成”就可以理解为对原工作的一种增强实现,这点有点类似于装饰器模式。

那么，为什么会存在代理模式呢?我们知道，存在即合理，很多情况下，客户类不想或不能直接用委托对象，这时候使用代理类充当中介作用，这种情况下代理类和委托类实现相同的接口；另外，有时候我们会想增强委托类，这个时候使用代理类来完成也是再合适不过了，也是符合开闭原则(对拓展开放，对修改关闭)的。

这里再简单提一下什么是正向代理什么是反向代理。

正向代理就是客户端对于服务器是匿名的，比如现在疫情在家，想查校园网有没有公布成绩。就使用了学校提供的代理软件，然后就能登上教务网站了。这个情景下，客户端对于服务器来说匿名了，服务器不知道是一个外网用户请求了消息，只知道内网来了一个请求。

反向代理就我们的服务器对客户端是匿名的。比如你去上百度，浏览器里输入 [www.baidu.com](http://www.baidu.com/) 之后回车跳转，但是你能确定是哪个服务器为你提供了服务吗？很显然这是做不到的，因为网页使用了反向代理，很多服务器在提供服务器。但是对外全都表现为了 [www.baidu.com。](http://www.baidu.com./)





## UML类图



![1](https://doc.shiyanlou.com/courses/1851/1240622/47bc127cc51f557f33fe9d09f58bc8e7-0)

代理模式也叫做委托模式，代理类一般包含被委托类的引用，我们来说下上面三个角色的定义:

- 抽象主题角色( Subject)：抽象主题角色往往是一个抽象类或接口，用来定义被委托类也就是真实的业务处理类和代理类的一些通用操作；
- 具体的主题角色( RealSubject)：该类实现 Subject，是真实被委托的类，也是具体业务逻辑的真正执行者；
- 代理类或委托类(Proxy)：该类同样实现 Subject,在客户类和本地之间充当中介作用，将客户端的业务操作委托给 RealSubject 执行，并在执行前后做一些预处理或者善后工作。 有点类似于 AOP，实际上 AOP 使用的也是代理模式，不过是动态代理。



## 应用实例—购票



关于购票类活动，我们生活中肯定也见过自己买票抢不到，求网速快的帮忙抢一下。或者自己去帮别人抢票，抢课之类的事情。这种时候，你就充当了一个代理者的角色。大家请先尝试按照下面的类图，自己实现代理模式。

![1](https://doc.shiyanlou.com/courses/1851/1240622/8ceeff32dedf483a46cbd84115e03827-0)

```go
package main

import "fmt"
// 买票的接口
type IBuyer interface {
    Login(username,password string)
    BuyTicket()
}
// 买票代理类
type BuyerProxy struct {
    b *Buyer
}

func (b *BuyerProxy)Login(username,password string)  {
    b.b.Login(username,password)
}
func (b *BuyerProxy)BuyTicket()  {
    before()
    b.b.BuyTicket()
    after()
}

func before() {
    fmt.Println("准备定时任务，开始刷票")
}

func after() {
    fmt.Println("刷票成功，短信通知用户")
}
// 具体买票者
type Buyer struct {
    name string
}

func (b *Buyer)Login(username,password string)  {
    fmt.Println(b.name,"使用",username,"账号登陆成功")
}

func (b *Buyer)BuyTicket()  {
    fmt.Println(b.name,"购票成功")
}
//进行测试
func main(){
    buyer := &Buyer{name: "tom"}
    proxy := BuyerProxy{b: buyer}
    proxy.Login("tom","jack")
    proxy.BuyTicket()
}
```

执行结果：

```go
tom 使用 jack 账号登录成功
开始购票
tom 购票成功
购票结束
```





# 总结



**享元模式**

优点：

- 有效减少内存占用，使得相似对象或相同对象在内存中只保留一份。
- 享元模式的外部状态相互独立，而不影响内部状态，从而使得享元对象可以在不同的环境中共享。

缺点：

- 内部状态与外部状态分离很复杂。
- 享元工厂的对象进行获取的过程中可能存在线程安全问题。

应用场景：

- 系统中存在大量相似对象，比如字符串池。
- 细粒度的对象必然存在比较接近的属性或状态可以抽取作为享元角色的外部状态，而且内部状态具有环境无关性。



**代理模式**

优点：

- 智能化：通过动态代理可以实现将处理过程映射到具体对象中。
- 中介隔离：隔离了客户端和目标类。
- 降低了系统耦合度，扩展性好。
- 有时可以增强目标对象的功能。

缺点：

- 多出代理类，导致类设计时数量增多，请求变慢。

应用场景：

需要静态代理或动态代理的场景。

