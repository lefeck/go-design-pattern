# 观察者模式



**观察者模式**是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。

举个例子：假如你有两种类型的对象，顾客和商店。顾客对某个特定品牌的产品非常感兴趣（例如最新型号的 iPhone 手机），而该产品很快将会在商店里出售。

顾客可以每天来商店看看产品是否到货。但如果商品尚未到货时，绝大多数来到商店的顾客都会空手而归。

另一方面，每次新产品到货时， 商店可以向所有顾客发送邮件（可能会被视为垃圾邮件）。这样，部分顾客就无需反复前往商店了，但也可能会惹恼对新产品没有兴趣的其他顾客。

我们似乎遇到了一个矛盾：要么让顾客浪费时间检查产品是否到货，要么让商店浪费资源去通知没有需求的顾客。



## 解决方法



拥有一些值得关注的状态的对象通常被称为*目标*，由于它要将自身的状态改变通知给其他对象，我们也将其称为*发布者*（publisher）。所有希望关注发布者状态变化的其他对象被称为*订阅者*（subscribers）。所以，观察者模式也被称作发布订阅模式。

观察者模式建议你为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。不要害怕！这并不像听上去那么复杂。实际上，该机制包括：

* 一个用于存储订阅者对象引用的列表成员变量。
* 几个用于添加或删除该列表中订阅者的公有方法。

现在，无论何时发生了重要的发布者事件，它都要遍历订阅者并调用其对象的特定通知方法。

实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件，你不会希望发布者与所有这些类相耦合的。此外如果他人会使用发布者类，那么你甚至可能会对其中的一些类一无所知。

因此，所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。

如果你的应用中有多个不同类型的发布者，且希望订阅者可兼容所有发布者，那么你甚至可以进一步让所有订阅者遵循同样的接口。该接口仅需描述几个订阅方法即可。这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。

下面我们就来看看观察者模式的类图。



## UML类图



![pic](https://doc.shiyanlou.com/courses/1851/1240622/deda5a17f26bfa56a5d5ff2176e1eea8-0)

组成角色：

- 具体发布者（ConcreteSubject）会向其他对象发送值得关注的事件。事件会在发布者自身状态改变或执行特定行为后发生。发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。
- 抽象主题（Subject）角色：该角色又称为“发布者”或被观察者，可以增加和删除观察者对象;
- 订阅者（Observer）接口声明了通知接口。在绝大多数情况下，该接口仅包含一个 `update` 更新方法。该方法可以拥有多个参数，使发布者能在更新时传递事件的详细信息。
- 具体订阅者（ConcreteObserver）可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口，因此发布者不需要与具体类相耦合。



## 应用实例



以生活中的读者订阅为例，假设，读者 A 和读者 B 订阅了某平台的图书，当有新的图书发布时就会给两位读者发送图书，实现代码如下。

```go
package main

import "fmt"

// 读者接口（订阅接口）
type IReader interface {
    Update(bookName string)
}

// 读者类（订阅者）
type Reader struct {
    name string
}

func (r *Reader) Update(bookName string) {
    fmt.Println(r.name,"-收到了图书",bookName)
}

// 平台接口（发布方接口）
type IPlatform interface {
    Attach(reader IReader)
    Detach(reader IReader)
    NotifyObservers(bookName string)
}

// 具体发布类（发布方）
type Platform struct {
    list []IReader
}

func (p *Platform) Attach(reader IReader) {
    // 增加读者（订阅者）
    p.list = append(p.list, reader)
}

func (p *Platform) Detach(reader IReader) {
    // 删除读者（订阅者）
    for i,v := range p.list {
        if v == reader {
            // 删除第i个元素,因为interface类型在golang中
            // 以地址的方式传递，所以可以直接比较进行删除
            // golang中只要记得byte,int,bool,string，数组，结构体，默认传值，其他的默认传地址即可
            p.list = append(p.list[:i],p.list[i+1:]...)
        }
    }
}

func (p *Platform) NotifyObservers(bookName string) {
    // 通知所有读者
    for _,reader := range p.list {
        reader.Update(bookName)
    }
}

func (p *Platform) Change (bookName string)  {
    p.NotifyObservers(bookName)
}
//主函数进行测试
func main(){
    // 创建图书平台（发布者）
    platform := Platform{list: []IReader{}}
    // 创建读者A
    reader := Reader{name:"A"}
    // 读者A订阅图书通知
    platform.Attach(&reader)
    // 创建读者B
    reader2 := Reader{name:"B"}
    // 读者B订阅图书通知
    platform.Attach(&reader2)
    platform.Change("《go核心编程》")
    // 读者B取消订阅
    platform.Detach(&reader2)
    platform.Change("《go高级编程》")
}
```

测试结果：

```
jinhuaiwang@jinhuaiwang-MBP designpattern % go run observer/demo1.go
A 收到了图书 go 核心编程
B 收到了图书 go 核心编程
A 收到了图书 go 高级编程
```



## 总结



观察者模式的优点:

- 观察者和被观察者之间，实现了抽象耦合。被观察者角色所知道的只是一个具体观察者集合，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体的观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密的耦合在一起，因此它们可以属于不同的抽象化层次，且都非常容易扩展；
- 此模式为广播模式，所有的观察者只需要订阅相应的主题，就能收到此主题下的所有广播。

观察者模式的缺点:

- 观察者只知道被观察者会发生变化，但不知道何时会发生变化；
- 如果主题之间有循环依赖，会导致系统崩溃，所以在使用时要特别注意此种情况；
- 如果有很多个观察者，则每个通知会比较耗时。

使用观察模式的典型应用场景如下:

- 关联行为的场景：例如，在一个系统中，如果用户完善了个人资料，就会增加积分、添加日志、开放一些功能权限等，就比较适合用观察者模式；
- 消息队列：例如，需要隔离发布者和订阅者，需要处理一对多关系的时候。

观察者模式与其他设计模式的关系：

- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：
  - *责任链*按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理。
  - *命令*在发送者和请求者之间建立单向连接。
  - *中介者*清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。
  - *观察者*允许接收者动态地订阅或取消接收请求。
- 中介者和观察者之间的区别往往很难记住。在大部分情况下，你可以使用其中一种模式，而有时可以同时使用。让我们来看看如何做到这一点。

*中介者*的主要目标是消除一系列系统组件之间的相互依赖。这些组件将依赖于同一个中介者对象。*观察者*的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。

有一种流行的中介者模式实现方式依赖于*观察者*。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。当*中介者*以这种方式实现时，它可能看上去与*观察者*非常相似。

当你感到疑惑时，记住可以采用其他方式来实现中介者。例如，你可永久性地将所有组件链接到同一个中介者对象。这种实现方式和*观察者*并不相同，但这仍是一种中介者模式。

假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。

