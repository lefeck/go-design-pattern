# 状态模式



状态模式允许一个对象在其内部状态改变时改变其行为，这个对象看起来好像是改变了其类。状态模式是一种对象行为型模式。



## UML类图



![pic](https://doc.shiyanlou.com/courses/1851/1240622/0b47fe9ec3260b51ab6414fc6f883af7-0)

状态模式包含角色如下:

- 上下文角色( Context)：上下文角色一般是一个类，上下文角色会聚合很多和 state，这些 state 使用静态常量修饰，并且负责 state 的状态切换；另外上下文角色还会包含抽象状态角色中定义的所有行为如 request，然后内部将请求委托给 state 的 handle 处理；
- 抽象状态角色(State)：抽象状态角色一般是一个抽象类，用来定义具体状态的公共行为比如 handle，任何具体状态都必须实现该抽象类中的抽象方法；
- 具体状态角色( ConcreteState)：继承抽象状态角色，实现抽象方法，实际处理来自 Context 的委托请求，当 Context 改变状态时行为也跟着改变。

## 优缺点

状态模式的优缺点:

- 减少代码体积，利于拓展：状态模式可以消除繁杂的条件判断语句块，使得业务逻辑清晰，很好地应对对象状态的增加、删除的业务场景，因为添加新的状态只需要增加新的状态类就好了；
- 状态模式状态很多时会导致状态类比较多，子类太多的时候就不方便维护管理了。



## 应用场景

状态模式的应用场景如下:

- 行为随状态改变而改变的场景；
- 化繁为简，如果代码中包含大量的条件语句块比如 `switch..case. if` 等，这些语句块的出现会导致业务逻辑变更时代码块也会变更，对状态的增加、删除时的调整修改起来比较吃力时就可以考虑状态模式。





## 使用实例—电视的操作



大家先想象一下平常使用的电视机，它有关闭，待机，播放三种状态，其中要播放就得先开机。关机的时候又要保证电视是开启的或者是待机的。总而言之我们每个操作都要考虑到一个 switch case 的操作，代码量大不说，还容易出错。



首先画出类图：

![state.png](https://github.com/wangjinh/picture/blob/master/state1.png?raw=true)

代码如下：

```go
package main

import "fmt"

// 引入控制器（上下文角色）
type RemoteControlMachine struct {
    currentSate TVState
}

func (r *RemoteControlMachine) PowerOn() {
    r.currentSate.PowerOn(r)
}

func (r *RemoteControlMachine) PowerOff() {
    r.currentSate.PowerOff(r)
}

func (r *RemoteControlMachine) Play() {
    r.currentSate.Play(r)
}

func (r *RemoteControlMachine) Standby() {
    r.currentSate.Standby(r)
}

func (r *RemoteControlMachine) CurrentSate() TVState {
    return r.currentSate
}

func (r *RemoteControlMachine) SetCurrentSate(currentSate TVState) {
    r.currentSate = currentSate
}


// 电视状态抽象接口
type TVState interface {
    // 开机
    PowerOn(r *RemoteControlMachine)
    // 关机
    PowerOff(r *RemoteControlMachine)
    // 播放
    Play(r *RemoteControlMachine)
    // 待机
    Standby(r *RemoteControlMachine)
}

// 待机状态
type StandByState struct {
    r *RemoteControlMachine
}

func (s *StandByState) PowerOn(r *RemoteControlMachine) {}

func (s *StandByState) PowerOff(r *RemoteControlMachine) {
    fmt.Println("关机")
    // 使用遥控器设置电视机状态为关机
    s.r = r
    s.r.SetCurrentSate(&PowerOffState{})
    // 执行关机
    s.r.PowerOff()
}

func (s *StandByState) Play(r *RemoteControlMachine) {
    fmt.Println("播放")
    // 使用遥控器设置电视机状态为播放
    s.r = r
    s.r.SetCurrentSate(&PlayState{})
    // 执行播放
    s.r.Play()
}

func (s *StandByState) Standby(r *RemoteControlMachine) {
    // do nothing
}

// 关机状态
type PowerOffState struct {
    r *RemoteControlMachine
}

func (s *PowerOffState) PowerOn(r *RemoteControlMachine) {
    fmt.Println("开机")
    // 使用遥控器设置电视机状态为开机
    s.r = r
    s.r.SetCurrentSate(&StandByState{})
    // 执行播放
    s.r.Standby()
}

func (s *PowerOffState) PowerOff(r *RemoteControlMachine) {
}

func (s *PowerOffState) Play(r *RemoteControlMachine) {
}

func (s PowerOffState) Standby(r *RemoteControlMachine) {
}

// 播放状态
type PlayState struct {
    r *RemoteControlMachine
}

func (s *PlayState) PowerOn(r *RemoteControlMachine) {}

func (s *PlayState) PowerOff(r *RemoteControlMachine) {
    fmt.Println("关机")
    // 使用遥控器设置电视机状态为关机
    s.r = r
    s.r.SetCurrentSate(&PowerOffState{})
    // 执行关机
    s.r.PowerOff()
}

func (s *PlayState) Play(r *RemoteControlMachine) {
}

func (s *PlayState) Standby(r *RemoteControlMachine) {
    fmt.Println("待机")
    // 使用遥控器设置电视机状态为待机
    s.r = r
    s.r.SetCurrentSate(&StandByState{})
    // 执行待机
    s.r.Standby()
}

//写入主函数进行测试
func main(){
    context := RemoteControlMachine{}

    context.SetCurrentSate(&PowerOffState{})
    // 如果直接播放，因为电视处于关机状态，所以不会有输出
    context.Play()

    context.PowerOn()
    context.Play()
    context.Standby()
    context.PowerOff()
}
```

测试结果：

```
jinhuaiwang@jinhuaiwang-MacBook-Pro designpattern % go run state/demo.go 
开机
播放
待机
关机
```

可以看到，测试结果没有任何不同，但是我们没有写一行 switch case 语句块，反而是将对象的各个状态抽出来做成状态类，然后各个状态类在对各个行为做出实现，代码更加可读。

状态模式具体的状态类在对状态做出变更时其行为也跟着做出变更，其实代码量减少并不十分明显，但是对于状态拓展十分友好，只需要增加状态类再实现各个行为即可拓展新的状态出来，也体现了开闭原则及单一职责原则；状态模式将对象状态的变更放到类的内部进行，外部调用者无需关心对象的状态及行为的变化，也体现了更好的封装性;另外对代码的重复率检测也是有明显提升。



# 备忘录模式



备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫**快照模式**。

备忘录模式是一种对象行为型模式，其主要优点如下。

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。

其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。





## 模式的结构与实现



备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，现在我们来学习其结构与实现。

备忘录模式的主要角色如下：

1. 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
2. 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
3. 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。



## UML类图



![pic](https://doc.shiyanlou.com/courses/1851/1240622/560451a3afcc8d09990bba6e95cf2ce9-0)





## 应用场景

1. 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。
2. 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。

```go
package main

import "fmt"
// 备忘录
type Memento struct {
    state string // 这里就是保存的状态
}

func (m *Memento) SetState(s string) {
    m.state = s
}

func (m *Memento) GetState() string {
    return m.state
}
// 发起人
type Originator struct {
    state string // 这里就简单一点，要保存的状态就是一个字符串
}

func (o *Originator) SetState(s string) {
    o.state = s
}

func (o *Originator) GetState() string {
    return o.state
}

// 这里就是规定了要保存的状态范围
func (o *Originator) CreateMemento() *Memento {
    return &Memento{state: o.state}
}
// 负责人
type Caretaker struct {
    memento *Memento
}

func (c *Caretaker) GetMemento() *Memento {
    return c.memento
}

func (c *Caretaker) SetMemento(m *Memento) {
    c.memento = m
}
```

主函数测试：

```go
func main(){
    // 创建一个发起人并设置初始状态
    // 此时与备忘录模式无关，只是模拟正常程序运行
    o := &Originator{state: "hello"}
    fmt.Println("当前状态:",o.GetState())
    // 现在需要保存当前状态
    // 就创建一个负责人来设置（一般来说，对于一个对象的同一个备忘范围，应当只有一个负责人，这样方便做多状态多备忘管理）
    c := new(Caretaker)
    c.SetMemento(o.CreateMemento())

    o.SetState("world")
    fmt.Println("更改当前状态:",o.GetState())
 
    // 恢复备忘
    o.SetState(c.GetMemento().GetState())
    fmt.Println("恢复后状态",o.GetState())
}
```

运行结果:

![pic](https://doc.shiyanlou.com/courses/1851/1240622/2532dee84b23ef0ed7dc957d883a340b-0)

